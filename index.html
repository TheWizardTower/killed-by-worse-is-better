<!doctype html>
<html lang="en">
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

		<title>reveal.js</title>

		<link rel="stylesheet" href="dist/reset.css">
		<link rel="stylesheet" href="dist/reveal.css">
		<link rel="stylesheet" href="dist/theme/black.css">

		<!-- Theme used for syntax highlighted code -->
		<link rel="stylesheet" href="plugin/highlight/monokai.css">
	</head>
	<body>
		<div class="reveal">
			<div class="slides">
				<section>Killed by 'Worse is Better'</section>
				<section>Some preliminaries:
				  <p><ul>
				    <li class="fragment">This isn't a technical talk.</li>
				    <ul>
				    <li class="fragment">More about philosophy, history, business, and responsibility</li>
				    </ul>
				    <li class="fragment">This isn't a cheerful talk</li>
				    </ul></p>
				</section>

				<section>
				  Overview:

				  <p />

				  <ol class="fragment">
			            <!-- <li>Testimony of an Engineer</li> -->
				    <li>"Why Isn't FP On Top?"</li>
				    <li>The past:</li>
				    <ol>
				      <li>LISP</li>
				      <li>Unix</li>
				    </ol>
				    <li>Observations?</li>
				    <li>Haskell</li>
				    <li>Golang</li>
				    <li>Prod Standard</li>
				    <li>Diagnosis</li>
				    <li>Prescription</li>
				  </ol>

				</section>

				<section>
				  Why isn't FP on top?

				  <img src="resource/collage.png" class="fragment" />
				</section>

				<section>
				  Why isn't FP on top?

				  <p class="fragment">It seems to be at the top of everyone's mind.</p>

				  <p class="fragment">Because, if you're already initiated, all you see are advantages</p>

				  <p class="fragment">Which suggests there's more to the story, but what is it?</p>
				</section>

				<section>
				  LISP!

				  <p class="fragment">What did LISP get right?</p>
				  <p />

				  <ol>
				    <li class="fragment">Elegant</li>
				    <ul>
				      <li class="fragment">"Maxwell's Equations for software" -- Alan Kay</li>
				      <li class="fragment">Lithe instantiation of the Lambda Calculus</li>
				    </ul>
				    <li class="fragment">Defined a pile of FP Idioms</li>
				    <li class="fragment">Also the first (to my knowledge) to call out "this function does IO" vs "This is a pure function"</li>
				    <ul>
				      <li class="fragment">Functions vs "pseudo-functions"</li>
				      </ul>
				    <li class="fragment">Also pioneered things like</li>
				    <ol>
				      <li class="fragment">Garbage Collection</li>
				      <li class="fragment">Dynamic Typing (but we won't hold that against it)</li>
				      <li class="fragment">REPLs!</li>
				      <li class="fragment">Tree Data Structures</li>
				      <li class="fragment">Self-Hosted Compiler</li>
				    </ol>
				  </ol>
				</section>

				<section>
				  Okay, what did UNIX get right?

				  <p />
				  <ul>
				    <li class="fragment">"Never bet against the cheap plastic model" --ESR</li>
				    <li class="fragment">Unix could run on machines that cost $10-20k, or up to a million</li>
				    <li class="fragment">So a well-off enthusiast could tinker with it at home, and apply those skills at work or Uni</li>
				    <li class="fragment">Aimed at correctness, but wasn't a slave to theory</li>
				  </ul>
				</section>

				<section>
				  ...but what did Unix innovate?

				  <p class="fragment">Well, to be honest, not a ton.</p>

				  <p class="fragment">It iterated much more rapidly, producing half a dozen standards from different outfits before Lisp produced one</p>

				  <p class="fragment">But didn't do anything tremendously groundbreaking</p>

				  <p class="fragment">It just did it in a way that became the lingua franca for CS departments in the 70s</p>

				  <p class="fragment">...and then hacker culture in the 90s</p>
				</section>

				<section>
				  The obvious comparison notices that the Unix slide has much less "ground-breaking firsts" than the LISP one had.

				  <p />Unix seemed to take a more iterative, fox-like/generalist approach, while Lisp was very much a specialist hedgehog.
				</section>

				<section>
				  Early personal Unix machines were hardly cheap, between 10-20k in 1980s dollars

				  <p class="fragment">...but Lisp machines were $50-80k</p>

				  <p class="fragment">...and slower.</p>

				  <p class="fragment">For reference, a new car in 1984 was about $6k. A nice sportscar could cost as much as $13k.</p>
				</section>

				<section>
				  ...and then there's all the Drama!

				  <p class="fragment">Faction one: LMI</p>
				  <ul class="fragment">
				    <li>Short for Lisp Machines, Inc</li>
				    <li>Founded in 1979</li>
				    <li>CEO Richard Greenblatt</li>
				    <li>Wanted to keep MIT's AI Lab atmosphere - open, informal, productive</li>
				    <li>Wanted to fund the lab Kickstarter-style, where customers buy the product, then they develop it</li>
				    <ul>
				      <li>To be fair, he found several people who were game...</li>
				    </ul>
				    <li>Wanted to spread the hacker ethos to the world, and thought the ideas were good enough to speak for themselves</li>
				    <ul>
				      <li>So, flat hierarchy, focus on excellence above all else, etc...</li>
				    </ul>
				  </ul>
				</section>


				<section>
				  <p>Faction two: Symbolics, Inc</p>

				  <p />
				  <ul class="fragment">
				    <li>Founded in 1980</li>
				    <li>CEO Russel Noftsker</li>
				    <li>Bet on hardware getting fast enough that high-level langs like Lisp would gain market share</li>
				    <li>Wanted to keep the MIT AI Lab going, felt that a commercial endeavor was the best way to fund it</li>
				    <li>Wanted to run a sales focused company</li>
				    <li>Compromise was alive and well, but in service of the same goal</li>
				  </ul>
				</section>


				<section>
				  So you had a language that was blindingly, staggeringly beautiful language that innovated so hard we're still cribbing notes from it, almost 70 years later...

				  <p class="fragment">...stuck on a machine that cost 3x as much as a more performant model</p>

				  <p class="fragment">So what happened is that it became monumentally influential, but itself faded largely to obscurity</p>
				</section>

				<section>
				  Okay, next up: Haskell

				  <p class="fragment">What were Haskell's goals?</p>

				  <ul class="fragment">
				    <li>Effects without cheating</li>
				    <ul><li>None of this "pseudo-function" black magic nonsense</li></ul>
				    <li>A common language for PLT research</li>
				    <ul>
				      <li>That used to be Miranda, but that was proprietary</li>
				      <li>Also, Miranda took the pseudo-function route, and the folks behind Haskell wanted to make lazy IO work properly</li>
				      <li>(To the point that Haskell didn't get side-effects until Haskell Report 1.3 in May of 1996)</li>
				    </ul>
				  </ul>
				</section>

				<section>
				  Cool. What was its *impact*?

				  <ul class="fragment">
				    <li>They succeeded in their goals:</li>
				    <ul>
				      <li>Common research language</li>
				      <li>Without deal-with-the-devil IO</li>
				      <li>More to the point, it's a tremendously fertile ground for new PLT research</li>
				      <ul>
					<li>Effect tracking systems, dependent types, STM, etc.</li>
				      </ul>
				    </ul>
				    <li>QuickCheck seems to have leaked out into the zeitgeist</li>
				    <li>It also is a benchmark for learning statically typed functional programming</li>
				    <li>For a while, it looked like it might grab the mainstream, but alas, not meant to be, for a pile of reasons</li>
				  </ul>
				</section>

				<section>
				  I'm not letting you off the hook that easily, what were those?

				  <ul>
				    <li class="fragment">Haskell didn't quite get their build tooling as airtight as it needs to be for industry use</li>
				    <li class="fragment">"The Cabal Treadmill" is not a sign of success</li>
				    <li class="fragment">Stack helped for a while, but that turned into its own political turf war</li>
				    <li class="fragment">They also got a lot of architecture changes exactly backwards</li>
				    <ul class="fragment">
				      <li>We *absolutely* need to change the API on this foundational library because it isn't perfect!</li>
				      <li>We *absolutely* cannot fix head, map, fold, think of all the textbooks that we'd invalidate!</li>
				    </ul>
				    <li class="fragment">Nevermind the political purity tests that narrowed the funnel even further</li>
				  </ul>
				</section>

				<section>
				  Let's contrast this with Go.

				  <p>Go's objectives:</p>
				  <ul>
				    <li class="fragment">Like C, except without the bad parts</li>
				    <li class="fragment">Like Python, but compiled and a bit faster</li>
				    <li class="fragment">Little-to-no extra tutorialization required</li>
				    <li class="fragment">No bikeshedding over formatting styles</li>
				    <li class="fragment">Easy concurrency. Channels and share-by-communicating</li>
				  </ul>
				</section>

				<section>
				  How'd it go?

				  <p class="fragment">Not great.</p>

				  <ul class="fragment">
				    <li>It's a language specifically designed to accomodate fresh-outs, and not scare, intimidate, or confuse them</li>
				    <li>It also got the semantics of its 'big killer feature' wrong.</li>
				    <ul class="fragment">
				      <li>Basically, go message passing semantics are bugged out of the box</li>
				      <li>They studied 171 concurrency bugs in things like Docker, K8s, gRPC, and others</li>
				      <li>MORE THAN HALF were because of "Non-traditional, go specific problems"</li>
				      <li><a href="https://songlh.github.io/paper/go-study.pdf">See here</a>
				    </ul>

				  </ul>
				</section>

				<section>
				  Is that it? Or is there more to it?

				  <p class="fragment">Hope you did the reading:</p> <br />
				  <p class="fragment"><a href="https://en.wikipedia.org/wiki/Range:_Why_Generalists_Triumph_in_a_Specialized_World"><img src="img/Range-_Why_Generalists_Triumph_in_a_Specialized_World.jpg" /></a></p>
				</section>

				<section>
				  One of the ideas advanced in this book is the notion of 'vicious' or 'virtuous' learning environments.

				  <p>An example of a virtuous learning environment is Chess. Another is Golf</p>

				  <p>Namely, the feedback you get is high-quality and can be taken at face-value</p>

				  <p>So, all things being equal, the more you study it, the better you get</p>
				</section>

				<section>
				  The book provides an example of a vicious learning environment, too, which Epstein credits to Robin Hogarth

				  <p class="fragment">A doctor had a sure-fire method of telling if someone was about to come down with Typhoid fever.</p>

				  <p class="fragment">He'd feel their patients tongues</p>
				</section>

				<section>
				  Business, it's worth noting, is a vicious learning environment

				  <p class="fragment">Meaning, things go absurdly wrong</p>

				  <p class="fragment">So to the suit's point, it's not fair to just say "make it right" and all will be well</p>

				  <p class="fragment">...and to the devs point, "do people love our app" is not a terribly interesting question if the app is not an interesting question</p>
				</section>

				<section>
				  We're confronting another issue, though, and that's best demonstrated with another anecdote

				  <p class="fragment">Setting: 1846, Vienna General Hospital</p>

				  <p class="fragment">A doctor noticed a strange thing:</p>

				  <p class="fragment">Two clinics in the hospital handled deliveries, one run by nurses, the other run by doctors.</p>
				</section>

				<section>
				  The one ran by nurses had a much better survival rate than the one at the University.

				  <p class="fragment">10% vs less than 4% fatality rate</p>
				</section>

				<section>
				  A doctor -- Ignaz Semmelweis -- noticed this, and started doing a systems analysis to figure out why

				  <p class="fragment">Was it that the nurses delivered babies on their side?</p>

				  <p class="fragment">Was it the priest ringing the bell as he walked to a patient to give last rights?</p>
				</section>

				<section>
				  Eventually, a breakthrough - a friend of Ignaz died.

				  <p class="fragment">He'd cut himself during an autopsy, and died soon after</p>

				  <p class="fragment">Not only that, but he died in a very similar way to how the monthers would die after childbirth</p>
				</section>

				<section>
				  Now we have a clue - is there something in the bodies that are getting autopsied that hurts people?

				  <p class="fragment">Okay, assume so - maybe you should wash hands after autopsies, before a delivery.</p>
				</section>

				<section>
				  The Doctors weren't happy about the suggestion, but he insisted.

				  <p class="fragment">Fatalities started dropping</p>
				</section>

				<section>
				  So, happy ending, right? The riddle was solved, the solution found, heroes ride into the sunset, right?

				  <p class="fragment">Well, no.</p>
				  <p class="fragment">Doctors didn't like the implication that they were making people sick</p>
				  <p class="fragment">Ignaz was also not the most polite or tactful person around</p>
				</section>

				<section>
				  <p class="fragment">Put in a blender, pulse until smooth, and he gets:</p>

				  <ul class="fragment">
				    <li>Fired</li>
				    <li>Ignored</li>
				    <li>Eventually committed to a mental asylum</li>
				    <li>(probably/maybe) developed a mental condition, likely connected to syphylus or Altzheimers</li>
				    <li>Died of Sepsis</li>
				  </ul>
				</section>

				<section>
				  So. This suggests a grim question.

				  <p class="fragment">If we have documented evidence that Doctors, with lives on the line, will sacrifice those lives for the sake of their own egos</p>

				  <p class="fragment">What hope do we have, as developers, to get others to admit they're wrong, and reform?</p>
				</section>

				<section>
				  Is it hopeless?

				  <p class="fragment">Oh, probably. But there are some things that can be done.</p>
				</section>

				<section>
				  Academia:

				  <p />
				  <ul class="fragment">
				    <li>These ideas are clearly worth attention. So teach them in undergrad.</li>
				    <li>Maybe we don't need to go all the way to depdendently typed effect tracking systems, but</li>
				    <ul class="fragment">
				      <li>Sum types and Product types</li>
				      <li>Maybe/Either (or Optional/Result) as a solution to the billion dollar mistake</li>
				      <li>HOFs + map/fold/filter as a way to solve off-by-one loop errors</li>
				      <li>We can compromise and make Monadic IO an elective</li>
				    </ul>
				    <li class="fragment">Tooling isn't a nice-to-have, or something you can stick in an SEP field</li>
				  </ul>
				</section>

				<section>
				  Industry:

				  <p />
				  <ul class="fragment">
				    <li>Invest in continual education for your talent</li>
				    <li>"The only thing worse than training your employees, and having them leave, is not trainin them, and having them stay." -- Henry Ford</li>
				    <li class="fragment">First-To-Market is not the end-all be-all. It also has to work.</li>
				    <li class="fragment">It's easier to make things work if you use tools that don't lie to you.</li>
				  </ul>
				</section>

				<section>
				  We've also forgotten how to discard broken tools.

				  <p class="fragment">When was the last time you used 'goto'?</p>
				</section>

				<section>
				  Practitioners:

				  <p />
				  <ul class="fragment">
				    <li>You'll have to invest in your own continued education, too.</li>
				    <li>Be ruthless about real, quantifiable behavior of the systems and code you steward</li>
				    <ul class="fragment">
				      <li>Is it safe?</li>
				      <li>Is it correct?</li>
				      <li>Is it Fast?</li>
				      <li>Is it a good servant to your customers?</li>
				      <li>Will the heirs of this system be able to manage it?</li>
				      <li>If not, what can be done to make it so?</li>
				    </ul>
				  </ul>
				</section>

				<section>
				  Everyone:

				  <p />
				  <ul class="fragment">
				    <li>Rusts tooling proves 'YAGNI' is a cop-out and a lie</li>
				    <li>A rust-grade error message only comes about when the team behind it is ruthless about treating "I read the message and I'm still confused" as a show-stopping bug.</li>
				  </ul>
				</section>

				<section>
				  Many things about business (and life) are uncertain, vicious, cruel, and capricious.

				  <p class="fragment">If you can make something that *delights* someone, you're on good ground</p>
				</section>

				<section>
				  Doing that requires laser focus, and a tool stack that treats you with honesty and respect -- enough to tell you when you're wrong

				  <p class="fragment">Not like Mephistopheles chasing a sales quota.</p>
				</section>

			</div>
		</div>

		<script src="dist/reveal.js"></script>
		<script src="plugin/notes/notes.js"></script>
		<script src="plugin/markdown/markdown.js"></script>
		<script src="plugin/highlight/highlight.js"></script>
		<script>
			// More info about initialization & config:
			// - https://revealjs.com/initialization/
			// - https://revealjs.com/config/
			Reveal.initialize({
				hash: true,

				// Learn about plugins: https://revealjs.com/plugins/
				plugins: [ RevealMarkdown, RevealHighlight, RevealNotes ]
			});
		</script>
	</body>
</html>
